[
  {
    "url": "https://api.github.com/repos/youmi/tech-blog/issues/3",
    "repository_url": "https://api.github.com/repos/youmi/tech-blog",
    "labels_url": "https://api.github.com/repos/youmi/tech-blog/issues/3/labels{/name}",
    "comments_url": "https://api.github.com/repos/youmi/tech-blog/issues/3/comments",
    "events_url": "https://api.github.com/repos/youmi/tech-blog/issues/3/events",
    "html_url": "https://github.com/youmi/tech-blog/issues/3",
    "id": 129715411,
    "number": 3,
    "title": "Alertover - 免费好用的团队消息工具",
    "user": {
      "login": "ruitao",
      "id": 1064207,
      "avatar_url": "https://avatars.githubusercontent.com/u/1064207?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ruitao",
      "html_url": "https://github.com/ruitao",
      "followers_url": "https://api.github.com/users/ruitao/followers",
      "following_url": "https://api.github.com/users/ruitao/following{/other_user}",
      "gists_url": "https://api.github.com/users/ruitao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ruitao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ruitao/subscriptions",
      "organizations_url": "https://api.github.com/users/ruitao/orgs",
      "repos_url": "https://api.github.com/users/ruitao/repos",
      "events_url": "https://api.github.com/users/ruitao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ruitao/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "milestone": null,
    "comments": 0,
    "created_at": "2015-01-29T09:39:41Z",
    "updated_at": "2015-01-29T10:11:17Z",
    "closed_at": null,
    "body": "稍微“古老”一点的互联网时代，我们一直用短信，邮件来进行消息通知，特别是服务器报警这些信息。短信虽好，但是太贵，而且没办法分类分组分级别，后来我们发现了Pushover，很好地解决了我们的问题。\r\n\r\n<!-- more -->\r\n本来我们是一直用Pushover的，但是由于众所周知的原因，Pushover的Android版本在国内没法用，而微信又满足不了我们的需求（分组，分级别推送消息），因此我们自己开发了一个Pushover的替代版：\r\n\r\nhttps://www.alertover.com\r\n\r\n免费实用。\r\n我们自己用在服务器报警，运营后台消息推送，已经用了近一年，大家可以放心使用。\r\n同时，我们即将开源Alertover的各类客户端源码。\r\n\r\n使用过程中有遇到任何问题，可以发邮件给我们 alertover@youmi.net，或者加我们的官方用户QQ群：313270450\r\n\r\n![www alertover com](https://cloud.githubusercontent.com/assets/1064207/12672140/1588e560-c6af-11e5-9aa8-f43509ffae9e.png)\r\n"
  },
  {
    "url": "https://api.github.com/repos/youmi/tech-blog/issues/1",
    "repository_url": "https://api.github.com/repos/youmi/tech-blog",
    "labels_url": "https://api.github.com/repos/youmi/tech-blog/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/youmi/tech-blog/issues/1/comments",
    "events_url": "https://api.github.com/repos/youmi/tech-blog/issues/1/events",
    "html_url": "https://github.com/youmi/tech-blog/issues/1",
    "id": 128743607,
    "number": 1,
    "title": "Upstart 系统初始化过程",
    "user": {
      "login": "divisoryang",
      "id": 2314596,
      "avatar_url": "https://avatars.githubusercontent.com/u/2314596?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/divisoryang",
      "html_url": "https://github.com/divisoryang",
      "followers_url": "https://api.github.com/users/divisoryang/followers",
      "following_url": "https://api.github.com/users/divisoryang/following{/other_user}",
      "gists_url": "https://api.github.com/users/divisoryang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/divisoryang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/divisoryang/subscriptions",
      "organizations_url": "https://api.github.com/users/divisoryang/orgs",
      "repos_url": "https://api.github.com/users/divisoryang/repos",
      "events_url": "https://api.github.com/users/divisoryang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/divisoryang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "milestone": null,
    "comments": 2,
    "created_at": "2015-01-26T07:13:04Z",
    "updated_at": "2015-01-29T03:38:19Z",
    "closed_at": null,
    "body": "Upstart是一个用于替代传统 init 的系统初始化程序。相对于 init 的同步执行，Upstart 是事件驱动、异步工作的。由于是事件驱动， Upstart 提供了传统 init 没法提供的功能，如机器运行时添加或删除U盘；由于异步工作，Upstart 更能充分利用CPU资源，性能更好。\r\n\r\n<!-- more -->\r\n\r\nUbuntu 是我们常用的开发和服务器系统，当前最新 LTS 使用的是 Upstart，了解 Upstart 可以帮我们解答以下这些疑惑：\r\n\r\n* 机器启动后的一些初始化脚本应该放在哪里比较合适？\r\n* 想要在某个通用服务启动前执行一段代码可以怎样做？\r\n* 设置好开机启动的程序运行时网络是否已经配置好？\r\n* 硬盘什么时候挂载的？\r\n* 在一些重启后某些硬盘内容会消失的云主机里什么时候初始化 flashcache？\r\n\r\n下面介绍一下日常最需要了解 Upstart 的一些方面：\r\n\r\n### 一、基本概念\r\n\r\nUpstart 的可执行文件就是系统里的 /sbin/init。它事件驱动的特性体现在通过一些事件来触发任务的执行，比如开机后有 startup 事件、启动一个 job 前有 starting xxx（job 的名字）事件、插入一个U盘也会有相应的事件。Upstart 的任务配置一般写在 /etc/init 目录下（其实还有用户的 Upstart 配置，可以放在 $HOME/.init 目录下）。\r\n\r\nUpstart job 的三个类型：\r\n\r\n1. Task Job： 运行一小会儿就停止的服务。\r\n2. Service Job： 一直运行的服务，比如 PHP-FPM、sshd。\r\n3. Abstract Job：没有 exec 和 script 的任务， Upstart 不会跟踪他的pid， 常用来设置网络服务。\r\n\r\n\r\n### 二、Upstart 在机器启动时的执行过程\r\n\r\n![ubuntu_upstart_procedure](https://cloud.githubusercontent.com/assets/2314596/12577547/e2abbdee-c455-11e5-99e4-f825db9f3f6b.png)\r\n\r\n在机器做完那些[加载内核，挂载跟目录等工作](http://www.yunweipai.com/archives/782.html)后，操作系统会调用 /sbin/init 来接管后续的服务启动过程。\r\n\r\n* init 启动后马上发出第一个事件 startup\r\n* hostname，mountall 会被 startup 事件触发（在 /etc/init 目录下 grep startup * 就可以看到了！)，也就是一启动就开始分别设置 hostname 和 挂载硬盘。\r\n\r\n\t在 mountall.conf 里可以看到它主要运行了 [mountall](http://manpages.ubuntu.com/manpages/vivid/man8/mountall.8.html) 程序，这个程序会读取 /lib/init/fstab 和 /etc/fstab 里的配置，按顺序挂载。其中 /lib/init/fstab 里的都是像 /proc /sys 这样的虚拟磁盘。\r\n\t\r\n\tmountall 会发出很多可以触发 Upstart 的事件：\r\n\t\r\n\t```\r\n\temits virtual-filesystems\r\n\temits local-filesystems\r\n\temits remote-filesystems\r\n\temits all-swaps\r\n\temits filesystem\r\n\temits mounting\r\n\temits mounted\r\n\t```\r\n\r\n\t每挂载好一个磁盘都会发出一个 mounted 事件，当挂载完 /lib/init/fstab 里的虚拟磁盘后会发出 virtual-filesystems 事件，mountall 继续处理 /etc/fstab 里的配置，期间会发出 remote-filesystems, all-swaps等事件，全部处理完后会发送 local-filesystems 和 filesystem 事件。\r\n\t\r\n\t也就是说，当 Upstart 接收到 filesystem 事件时，配置文件中的磁盘已经挂载好了。\r\n\t\r\n\tmountall 发出的很多事件，有些是以[阻塞的方式](http://upstart.ubuntu.com/cookbook/#event-types)发出的，也就是在 mountall 过程中有些别的任务已经被触发并且可能已经完成了。\r\n\r\n* udev.conf 在接收到 virtual-filesystem 时出发，这是一个管理 /dev 下的设备描述的程序。\r\n\t* udev 导致 upstart-udev-bridge 任务执行，这个任务会设置好 127.0.0.0 这个网络回路地址。\r\n\t* udev 和 filesystem 事件还是开始网络设置的前提。\r\n* 在设置网络之前，ufw 的配置也会准备就绪。\r\n* 网络和文件系统都准备好后出发 rc-sysinit.conf 里的脚本执行，里面其实就是打开 telinit 程序并传入一个2作为参数，这个程序发出 runlevel 事件。\r\n\t* rc.conf 会被 runlevel 事件触发，它会调用 /etc/init.d/rc 2 ， 这是兼容传统 init 的关键步骤。\r\n\t* 其他 job 也会被 runlevel 事件触发，例如 cron、ssh、irqbalance 等。\r\n\r\n### 三、 和传统 init 的兼容\r\n\r\nUpstart 兼容传统的 init 也称为 sysV 的启动方式，从上面步骤可以看到在 /etc/init/rc.conf 里调用了 /etc/init.d/rc 2， 这个程序会遍历 /etc/rc2.d 目录下的脚本并执行。\r\n\r\n平时我们启动服务会用到下面这几种命令：\r\n\r\n```\r\nservice x start\r\nstart x\r\ninitctl start x\r\n```\r\n\r\n其中 service 是一个脚本，它的工作原理是先检查 /etc/init 里的配置有没有这个命令要启动的服务，如果没有才到 /etc/init.d 里找到启动那个服务的脚本并执行。如果你通过 apt-get 安装 PHP-FPM 可以发现 /etc/init.d 里的 PHP-FPM 启动脚本并不会被 service php5-fpm start 调用。\r\n\r\n### 参考资料\r\n\r\n* [Upstart cookbook](http://upstart.ubuntu.com/cookbook)\r\n* [Linux操作系统启动过程详解](http://www.yunweipai.com/archives/782.html)\r\n* [mountall](http://manpages.ubuntu.com/manpages/vivid/man8/mountall.8.html)\r\n* [Udev](https://zh.wikipedia.org/wiki/Udev)\r\n"
  }
]
